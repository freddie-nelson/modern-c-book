- [x] Level 0. Encounter 1

  - [x] 1. Getting started 2

    - [x] 1.1. Imperative programming 2
    - [x] Summary 7
    - [x] 1.2. Compiling and running 4

  - [x] 2. The principal structure of a program 8
    - [x] 2.1. Grammar 8
    - [x] 2.2. Declarations 9
    - [x] 2.3. Definitions 11
    - [x] 2.4. Statements 13
    - [x] Summary 15

- [] Level 1. Acquaintance 17

  - [] Buckle up 18
  - [] 3. Everything is about control 21

    - [] 3.1. Conditional execution 21
    - [] 3.2. Iterations 23
    - [] 3.3. Multiple selection 27
    - [] Summary 28

  - [] 4. Expressing computations 29

    - [] 4.1. Arithmetic 29
    - [] 4.2. Operators that modify objects 32
    - [] 4.3. Boolean context 33
    - [] 4.4. The ternary or conditional operator 35
    - [] 4.5. Evaluation order 35
    - [] Summary 36

  - [] 5. Basic values and data 38

    - [] 5.1. The abstract state machine 38
    - [] 5.2. Basic types 42
    - [] 5.3. Specifying values 45
    - [] 5.4. Implicit conversions 48
    - [] 5.5. Initializers 50
    - [] 5.6. Named constants 51
    - [] 5.7. Binary representions 56
    - [] Summary 63

  - [] 6. Derived data types 65

    - [] 6.1. Arrays 65
    - [] 6.2. Pointers as opaque types 71
    - [] 6.3. Structures 73
    - [] 6.4. New names for types: type aliases 78
    - [] Summary 79

  - [] 7. Functions 80

    - [] 7.1. Simple functions 80
    - [] 7.2. main is special 82
    - [] 7.3. Recursion 84
    - [] Summary 89

  - [] 8. C library functions 90
    - [] 8.1. General properties of the C library and its functions 90
    - [] 8.2. Mathematics 94
    - [] 8.3. Input, output, and file manipulation 96
    - [] 8.4. String processing and conversion 105
    - [] 8.5. Time 109
    - [] 8.6. Runtime environment settings 111
    - [] 8.7. Program termination and assertions 113
    - [] Summary 115

- [] Level 2. Cognition 117

  - [] 9. Style 118

    - [] 9.1. Formatting 118
    - [] 9.2. Naming 119
    - [] Summary 122

  - [] 10. Organization and documentation 123

    - [] 10.1. Interface documentation 124
    - [] 10.2. Implementation 126
    - [] Summary 132

  - [] 11. Pointers 133

    - [] 11.1. Pointer operations 133
    - [] 11.2. Pointers and structures 140
    - [] 11.3. Pointers and arrays 143
    - [] 11.4. Function pointers 145
    - [] Summary 149

  - [] 12. The C memory model 150

    - [] 12.1. A uniform memory model 150
    - [] 12.2. Unions 152
    - [] 12.3. Memory and state 153
    - [] 12.4. Pointers to unspecific objects 154
    - [] 12.5. Explicit conversions 155
    - [] 12.6. Effective types 156
    - [] 12.7. Alignment 157
    - [] Summary 159

  - [] 13. Storage 160

    - [] 13.1. malloc and friends 160
    - [] 13.2. Storage duration, lifetime, and visibility 168
    - [] 13.3. Digression: using objects "before" their definition 173
    - [] 13.4. Initialization 175
    - [] 13.5. Digression: a machine model 177
    - [] Summary 179

  - [] 14. More involved processing and IO 181
    - [] CONTENTS vii
    - [] 14.1. Text processing 181
    - [] 14.2. Formatted input 186
    - [] 14.3. Extended character sets 188
    - [] 14.4. Binary streams 195
    - [] 14.5. Error checking and cleanup 196
    - [] Summary 200

- [] Level 3. Experience 203

  - [] 15. Performance 203

    - [] 15.1. Inline functions 206
    - [] 15.2. Using restrict qualifiers 209
    - [] 15.3. Measurement and inspection 210
    - [] Summary 217

  - [] 16. Function-like macros 218

    - [] 16.1. How function-like macros work 219
    - [] 16.2. Argument checking 221
    - [] 16.3. Accessing the calling context 224
    - [] 16.4. Default arguments 226
    - [] 16.5. Variable-length argument lists 227
    - [] 16.6. Type-generic programming 234
    - [] Summary 239

  - [] 17. Variations in control flow 240

    - [] 17.1. A complicated example 241
    - [] 17.2. Sequencing 244
    - [] 17.3. Short jumps 246
    - [] 17.4. Functions 247
    - [] 17.5. Long jumps 247
    - [] 17.6. Signal handlers 252
    - [] Summary 260

  - [] 18. Threads 261

    - [] 18.1. Simple inter-thread control 263
    - [] 18.2. Race-free initialization and destruction 265
    - [] 18.3. Thread-local data 267
    - [] 18.4. Critical data and critical sections 268
    - [] 18.5. Communicating through condition variables 271
    - [] 18.6. More sophisticated thread management 275
    - [] Summary 277

  - [] 19. Atomic access and memory consistency 278
    - [] 19.1. The “happened before” relation 279
    - [] 19.2. C library calls that provide synchronization 281
    - [] 19.3. Sequential consistency 283
    - [] 19.4. Other consistency models 285
    - [] Summary 286
